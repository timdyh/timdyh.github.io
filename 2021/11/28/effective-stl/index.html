<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: light)">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: dark)"><meta name="generator" content="Hexo 6.1.0">

<link rel="preconnect" href="https://fonts.googleapis.com" crossorigin>
<link rel="preconnect" href="null//null" crossorigin>
<link rel="preconnect" href="https://cdn.jsdelivr.net" crossorigin>
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">
  <meta name="google-site-verification" content="x_9IHIiVX0aZQfKSCtN7gy8_1UhN7guVmZAmA4gv1EE">
  <meta name="msvalidate.01" content="AC8F448726B8A8742C6DFFA7640E7DBF">
  <meta name="baidu-site-verification" content="code-2qEdijyCxz">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.1.1/css/all.min.css" integrity="sha256-DfWjNxDkM94fVBWx1H5BMMp0Zq7luBlV8QRcSES7s+0=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css" integrity="sha256-Vzbj7sDDS/woiFS3uNKo8eIuni59rjyNGtXfstRzStA=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"example.com","root":"/","images":"/images","scheme":"Gemini","darkmode":true,"version":"8.11.1","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":true,"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":true,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":true,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"Searching...","empty":"We didn't find any results for the search: ${query}","hits_time":"${hits} results found in ${time} ms","hits":"${hits} results found"}}</script><script src="/js/config.js"></script>

    <meta name="description" content="Only you know enough about the software you’re writing, the environment in which it will run, and the context in which it’s being created to determine whether it’s reasonable to violate the guideline">
<meta property="og:type" content="article">
<meta property="og:title" content="[Note] Effective STL">
<meta property="og:url" content="http://example.com/2021/11/28/effective-stl/index.html">
<meta property="og:site_name" content="TimDyh">
<meta property="og:description" content="Only you know enough about the software you’re writing, the environment in which it will run, and the context in which it’s being created to determine whether it’s reasonable to violate the guideline">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://ipichub.oss-cn-hangzhou.aliyuncs.com/2022-07-09-083816.png">
<meta property="og:image" content="https://ipichub.oss-cn-hangzhou.aliyuncs.com/2022-07-09-084208.png">
<meta property="og:image" content="https://ipichub.oss-cn-hangzhou.aliyuncs.com/2022-07-17-050643.png">
<meta property="article:published_time" content="2021-11-28T14:49:19.000Z">
<meta property="article:modified_time" content="2022-11-19T07:17:12.835Z">
<meta property="article:author" content="Yuheng Ding">
<meta property="article:tag" content="C&#x2F;C++">
<meta property="article:tag" content="STL">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://ipichub.oss-cn-hangzhou.aliyuncs.com/2022-07-09-083816.png">


<link rel="canonical" href="http://example.com/2021/11/28/effective-stl/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"en","comments":true,"permalink":"http://example.com/2021/11/28/effective-stl/","path":"2021/11/28/effective-stl/","title":"[Note] Effective STL"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>[Note] Effective STL | TimDyh</title>
  





  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">TimDyh</p>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>About</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a></li>
  </ul>
</nav>




</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#item-1.-choose-your-containers-with-care."><span class="nav-number">1.</span> <span class="nav-text">Item 1. Choose your
containers with care.</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#item-2.-beware-the-illusion-of-container-independent-code."><span class="nav-number">2.</span> <span class="nav-text">Item
2. Beware the illusion of container-independent code.</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#item-3.-make-copying-cheap-and-correct-for-objects-in-containers."><span class="nav-number">3.</span> <span class="nav-text">Item
3. Make copying cheap and correct for objects in containers.</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#item-4.-call-empty-instead-of-checking-size-against-zero."><span class="nav-number">4.</span> <span class="nav-text">Item
4. Call empty instead of checking size() against zero.</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#item-5.-prefer-range-member-functions-to-their-single-element-counterparts."><span class="nav-number">5.</span> <span class="nav-text">Item
5. Prefer range member functions to their single-element
counterparts.</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#item-6.-be-alert-for-cs-most-vexing-parse."><span class="nav-number">6.</span> <span class="nav-text">Item 6. Be alert for
C++&#39;s most vexing parse.</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#item-7.-when-using-containers-of-newed-pointers-remember-to-delete-the-pointers-before-the-container-is-destroyed."><span class="nav-number">7.</span> <span class="nav-text">Item
7. When using containers of newed pointers, remember to delete the
pointers before the container is destroyed.</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#item-8.-never-create-containers-of-auto_ptrs."><span class="nav-number">8.</span> <span class="nav-text">Item 8. Never
create containers of auto_ptrs.</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#item-9.-choose-carefully-among-erasing-options."><span class="nav-number">9.</span> <span class="nav-text">Item 9. Choose
carefully among erasing options.</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#item-10.-be-aware-of-allocator-conventions-and-restrictions."><span class="nav-number">10.</span> <span class="nav-text">Item
10. Be aware of allocator conventions and restrictions.</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#item-11.-understand-the-legitimate-uses-of-custom-allocators."><span class="nav-number">11.</span> <span class="nav-text">Item
11. Understand the legitimate uses of custom allocators.</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#item-12.-have-realistic-expectations-about-the-thread-safety-of-stl-containers."><span class="nav-number">12.</span> <span class="nav-text">Item
12. Have realistic expectations about the thread safety of STL
containers.</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#item-13.-prefer-vector-and-string-to-dynamically-allocated-arrays."><span class="nav-number">13.</span> <span class="nav-text">Item
13. Prefer vector and string to dynamically allocated arrays.</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#item-14.-use-reserve-to-avoid-unnecessary-reallocations."><span class="nav-number">14.</span> <span class="nav-text">Item
14. Use reserve to avoid unnecessary reallocations.</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#item-15.-be-aware-of-variations-in-string-implementations."><span class="nav-number">15.</span> <span class="nav-text">Item
15. Be aware of variations in string implementations.</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#item-16.-know-how-to-pass-vector-and-string-data-to-legacy-apis."><span class="nav-number">16.</span> <span class="nav-text">Item
16. Know how to pass vector and string data to legacy APIs.</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#item-17.-use-the-swap-trick-to-trim-excess-capacity."><span class="nav-number">17.</span> <span class="nav-text">Item 17.
Use &quot;the swap trick&quot; to trim excess capacity.</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#item-18.-avoid-using-vectorbool."><span class="nav-number">18.</span> <span class="nav-text">Item 18. Avoid using
vector&lt;bool&gt;.</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#item-19.-understand-the-difference-between-equality-and-equivalence."><span class="nav-number">19.</span> <span class="nav-text">Item
19. Understand the difference between equality and equivalence.</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#item-20.-specify-comparison-types-for-associative-containers-of-pointers."><span class="nav-number">20.</span> <span class="nav-text">Item
20. Specify comparison types for associative containers of
pointers.</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#item-21.-always-have-comparison-functions-return-false-for-equal-values."><span class="nav-number">21.</span> <span class="nav-text">Item
21. Always have comparison functions return false for equal values.</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#item-22.-avoid-in-place-key-modification-in-set-and-multiset."><span class="nav-number">22.</span> <span class="nav-text">Item
22. Avoid in-place key modification in set and multiset.</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#item-23.-consider-replacing-associative-containers-with-sorted-vectors."><span class="nav-number">23.</span> <span class="nav-text">Item
23. Consider replacing associative containers with sorted vectors.</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#item-24.-choose-carefully-between-mapoperator-and-map-insert-when-efficiency-is-important."><span class="nav-number">24.</span> <span class="nav-text">Item
24. Choose carefully between map::operator[] and map-insert when
efficiency is important.</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#item-25.-familiarize-yourself-with-the-nonstandard-hashed-containers."><span class="nav-number">25.</span> <span class="nav-text">Item
25. Familiarize yourself with the nonstandard hashed containers.</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#item-26.-prefer-iterator-to-const-iterator-reverse_iterator-and-const_reverse_iterator."><span class="nav-number">26.</span> <span class="nav-text">Item
26. Prefer iterator to const iterator, reverse_iterator, and
const_reverse_iterator.</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#item-27.-use-distance-and-advance-to-convert-a-containers-const_iterators-to-iterators."><span class="nav-number">27.</span> <span class="nav-text">Item
27. Use distance and advance to convert a container&#39;s const_iterators to
iterators.</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#item-28.-understand-how-to-use-a-reverse_iterators-base-iterator."><span class="nav-number">28.</span> <span class="nav-text">Item
28. Understand how to use a reverse_iterator&#39;s base iterator.</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#item-29.-consider-istreambuf_iterators-for-character-by-character-input."><span class="nav-number">29.</span> <span class="nav-text">Item
29. Consider istreambuf_iterators for character-by-character input.</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#item-30.-make-sure-destination-ranges-are-big-enough."><span class="nav-number">30.</span> <span class="nav-text">Item 30.
Make sure destination ranges are big enough.</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#item-31.-know-your-sorting-options."><span class="nav-number">31.</span> <span class="nav-text">Item 31. Know your sorting
options.</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#item-32.-follow-remove-like-algorithms-by-erase-if-you-really-want-to-remove-something."><span class="nav-number">32.</span> <span class="nav-text">Item
32. Follow remove-like algorithms by erase if you really want to remove
something.</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#item-33.-be-wary-of-remove-like-algorithms-on-containers-of-pointers."><span class="nav-number">33.</span> <span class="nav-text">Item
33. Be wary of remove-like algorithms on containers of pointers.</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#item-34.-note-which-algorithms-expect-sorted-ranges."><span class="nav-number">34.</span> <span class="nav-text">Item 34.
Note which algorithms expect sorted ranges.</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#item-35.-implement-simple-case-insensitive-string-comparisons-via-mismatch-or-lexicographical-compare."><span class="nav-number">35.</span> <span class="nav-text">Item
35. Implement simple case-insensitive string comparisons via mismatch or
lexicographical compare.</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#item-36.-understand-the-proper-implementation-of-copy_if."><span class="nav-number">36.</span> <span class="nav-text">Item
36. Understand the proper implementation of copy_if.</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#item-37.-use-accumulate-or-for_each-to-summarize-ranges."><span class="nav-number">37.</span> <span class="nav-text">Item
37. Use accumulate or for_each to summarize ranges.</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#item-38.-design-functor-classes-for-pass-by-value."><span class="nav-number">38.</span> <span class="nav-text">Item 38.
Design functor classes for pass-by-value.</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#item-39.-make-predicates-pure-functions."><span class="nav-number">39.</span> <span class="nav-text">Item 39. Make
predicates pure functions.</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#item-40.-make-functor-classes-adaptable."><span class="nav-number">40.</span> <span class="nav-text">Item 40. Make functor
classes adaptable.</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#item-41.-understand-the-reasons-for-ptr_fun-mem_fun-and-mem_fun_ref."><span class="nav-number">41.</span> <span class="nav-text">Item
41. Understand the reasons for ptr_fun, mem_fun, and mem_fun_ref.</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#item-42.-make-sure-lesst-means-operator"><span class="nav-number">42.</span> <span class="nav-text">Item 42. Make sure
less&lt;T&gt; means operator&lt;</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#item-43.-prefer-algorithm-calls-to-hand-written-loops."><span class="nav-number">43.</span> <span class="nav-text">Item 43.
Prefer algorithm calls to hand-written loops.</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#item-44.-prefer-member-functions-to-algorithms-with-the-same-names."><span class="nav-number">44.</span> <span class="nav-text">Item
44. Prefer member functions to algorithms with the same names.</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#item-45.-distinguish-among-count-find-binary-search-lower_bound-upper_bound-and-equal_range."><span class="nav-number">45.</span> <span class="nav-text">Item
45. Distinguish among count, find, binary search, lower_bound,
upper_bound, and equal_range.</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#item-46.-consider-function-objects-instead-of-functions-as-algorithm-parameters."><span class="nav-number">46.</span> <span class="nav-text">Item
46. Consider function objects instead of functions as algorithm
parameters.</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#item-47.-avoid-producing-write-only-code."><span class="nav-number">47.</span> <span class="nav-text">Item 47. Avoid
producing write-only code.</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#item-48.-always-include-the-proper-headers."><span class="nav-number">48.</span> <span class="nav-text">Item 48. Always
#include the proper headers.</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#item-49.-learn-to-decipher-stl-related-compiler-diagnostics."><span class="nav-number">49.</span> <span class="nav-text">Item
49. Learn to decipher STL-related compiler diagnostics.</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#item-50.-familiarize-yourself-with-stl-related-web-sites."><span class="nav-number">50.</span> <span class="nav-text">Item
50. Familiarize yourself with STL-related web sites.</span></a></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Yuheng Ding"
      src="/images/avatar.png">
  <p class="site-author-name" itemprop="name">Yuheng Ding</p>
  <div class="site-description" itemprop="description">Per aspera, ad astra.</div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">42</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">5</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">38</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author site-overview-item animated">
      <span class="links-of-author-item">
        <a href="https://github.com/timdyh" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;timdyh" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:dyh0701@gmail.com" title="E-Mail → mailto:dyh0701@gmail.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://twitter.com/tim_dyh" title="Twitter → https:&#x2F;&#x2F;twitter.com&#x2F;tim_dyh" rel="noopener" target="_blank"><i class="fab fa-twitter fa-fw"></i>Twitter</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://www.zhihu.com/people/timdyh" title="Zhihu → https:&#x2F;&#x2F;www.zhihu.com&#x2F;people&#x2F;timdyh" rel="noopener" target="_blank"><i class="fab fa-zhihu fa-fw"></i>Zhihu</a>
      </span>
  </div>



        </div>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top" role="button" aria-label="Back to top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/11/28/effective-stl/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="Yuheng Ding">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="TimDyh">
      <meta itemprop="description" content="Per aspera, ad astra.">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="[Note] Effective STL | TimDyh">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          [Note] Effective STL
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2021-11-28 22:49:19" itemprop="dateCreated datePublished" datetime="2021-11-28T22:49:19+08:00">2021-11-28</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Note/" itemprop="url" rel="index"><span itemprop="name">Note</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="Symbols count in article">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">Symbols count in article: </span>
      <span>56k</span>
    </span>
    <span class="post-meta-item" title="Reading time">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">Reading time &asymp;</span>
      <span>51 mins.</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
        <blockquote>
<p>Only you know enough about the software you’re writing, the
environment in which it will run, and the context in which it’s being
created to determine whether it’s reasonable to violate the guidelines I
present. Most of the time, it won’t be, and the discussions that
accompany each Item explain why. In a few cases, it will. Slavish
devotion to the guidelines isn’t appropriate, but neither is cavalier
disregard. Before venturing off on your own, you should make sure you
have a good reason.</p>
</blockquote>
<span id="more"></span>
<h3 id="item-1.-choose-your-containers-with-care.">Item 1. Choose your
containers with care.</h3>
<ul>
<li>An overview of containers:
<ul>
<li><strong>Sequence containers:</strong> vector, string, deque, and
list.</li>
<li><strong>Associative containers:</strong> set, multiset, map and
multimap.</li>
<li><strong>Nonstandard sequence containers:</strong> slist and
rope.</li>
<li><strong>Nonstandard associative containers:</strong> hash_set,
hash_multiset, hash_map, and hash_multimap.</li>
<li><strong>vector&lt;char&gt; as a replacement for
string.</strong></li>
<li><strong>vector as a replacement for the standard associative
containers.</strong></li>
<li><strong>Standard non-STL containers:</strong> arrays, bitset,
valarray, stack, queue, and priority_queue.</li>
</ul></li>
<li>A way of categorizing the STL containers:
<ul>
<li><em>Contiguous-memory containers</em> (also known as <em>array-based
containers</em>): vector, string, deque, and nonstandard rope.</li>
<li><em>Node-based containers</em>: list, slist, all the standard
associative containers and the nonstandard hashed containers.</li>
</ul></li>
<li>Some of the questions most relevant when choosing among containers:
<ul>
<li>Do you need to be able to insert a new element at an arbitrary
position in the container? If so, you need a sequence container:
associative containers won't do.</li>
<li>Do you care how elements are ordered in the container? If not, a
hashed container becomes a viable choice. Otherwise, you'll want to
avoid hashed containers.</li>
<li>Must the container be part of standard C++? If so, that eliminates
hashed containers, slist, and rope.</li>
<li>What category of iterators do you require? If they must be random
access iterators, you're technically limited to vector, deque, and
string, but you'd probably want to consider rope, too. If bidirectional
iterators are required, you must avoid slist as well as one common
implementation of the hashed containers.</li>
<li>Is it important to avoid movement of existing container elements
when insertions or erasures take place? If so, you'll need to stay away
from contiguous-memory containers.</li>
<li>Does the data in the container need to be layout-compatible with C?
If so, you're limited to vectors.</li>
<li>Is lookup speed a critical consideration? If so, you'll want to look
at hashed containers, sorted vectors, and the standard associative
containers — probably in that order.</li>
<li>Do you mind if the underlying container uses reference counting? If
so, you'll want to steer clear of string, because many string
implementations are reference-counted. You'll need to avoid rope, too,
because the definitive rope implementation is based on reference
counting. You have to represent your strings somehow, of course, so
you'll want to consider vector&lt;char&gt;.</li>
<li>Do you need transactional semantics for insertions and erasures?
That is, do you require the ability to reliably roll back insertions and
erasures? If so, you'll want to use a node-based container. If you need
transactional semantics for multiple-element insertions (e.g., the range
form), you'll want to choose list, because list is the only standard
container that offers transactional semantics for multiple-element
insertions. Transactional semantics are particularly important for
programmers interested in writing exception-safe code.</li>
<li>Do you need to minimize iterator, pointer, and reference
invalidation? If so, you'll want to use node-based containers, because
insertions and erasures on such containers never invalidate iterators,
pointers, or references (unless they point to an element you are
erasing). In general, insertions or erasures on contiguous-memory
containers may invalidate all iterators, pointers, and references into
the container.</li>
<li>Would it be helpful to have a sequence container with random access
iterators where pointers and references to the data are not invalidated
as long as nothing is erased and insertions take place only at the ends
of the container? This is a very special case, but if it's your case,
deque is the container of your dreams. (Interestingly, deque's iterators
may be invalidated when insertions are made only at the ends of the
container, deque is the only standard STL container whose iterators may
be invalidated without also invalidating its pointers and
references.)</li>
</ul></li>
</ul>
<h3 id="item-2.-beware-the-illusion-of-container-independent-code.">Item
2. Beware the illusion of container-independent code.</h3>
<ul>
<li>The different containers are <strong>different</strong>, and they
have strengths and weaknesses that vary in significant ways. They're not
designed to be interchangeable, and there's little you can do to paper
that over.</li>
<li>When you change container types:
<ul>
<li>You need to examine all the code using the container to see what
needs to be changed in light of the new container's performance
characteristics and rules for invalidation of iterators, pointers, and
references.</li>
<li>If you switch from a vector to something else, you'll also have to
make sure you're no longer relying on vector's C-compatible memory
layout.</li>
<li>If you switch to a vector, you'll have to ensure that you're not
using it to store bools.</li>
</ul></li>
<li>Given the inevitability of having to change container types from
time to time, you can facilitate such changes in the usual manner: by
encapsulating. One of the easiest ways to do this is through the liberal
use of typedefs for container and iterator types.</li>
<li>To limit the code that may require modification if you replace one
container type with another, hide the container in a class, and limit
the amount of container-specific information visible through the class
interface.</li>
</ul>
<h3
id="item-3.-make-copying-cheap-and-correct-for-objects-in-containers.">Item
3. Make copying cheap and correct for objects in containers.</h3>
<ul>
<li>An easy way to make copying efficient, correct, and immune to the
slicing problem is to create containers of pointers instead of
containers of objects.</li>
<li>Compared to arrays, STL containers are much more civilized. They
create (by copying) only as many objects as you ask for, they do it only
when you direct them to, and they use a default constructor only when
you say they should.</li>
</ul>
<h3 id="item-4.-call-empty-instead-of-checking-size-against-zero.">Item
4. Call empty instead of checking size() against zero.</h3>
<ul>
<li>You should prefer the construct using empty, and the reason is
simple: empty is a constant-time operation for all standard containers,
but for some list implementations, size takes linear time.</li>
<li>List can't offer a constant-time size due to its unique splicing
functions. If splice is made constant-time, then size becomes a
linear-time operation. One or the other can be a constant-time
operation, but not both.</li>
</ul>
<h3
id="item-5.-prefer-range-member-functions-to-their-single-element-counterparts.">Item
5. Prefer range member functions to their single-element
counterparts.</h3>
<ul>
<li>Whenever you have to completely replace the contents of a container,
you should think of assignment. If you're just copying one container to
another of the same type, operator= is the assignment function of
choice, but assign is available for the times when you want to give a
container a completely new set of values, but operator= won't do what
you want.</li>
<li>A <em>range member function</em> is a member function that, like STL
algorithms, uses two iterator parameters to specify a range of elements
over which something should be done.</li>
<li>Reasons to prefer range member functions to their single-element
counterparts:
<ul>
<li>It's generally less work to write the code using the range member
functions.</li>
<li>Range member functions tend to lead to code that is clearer and more
straightforward.</li>
<li>When dealing with the standard sequence containers, application of
single-element member functions makes more demands on memory allocators,
copies objects more frequently, and/or performs redundant operations
compared to range member functions that achieve the same end.</li>
</ul></li>
<li>Almost all uses of copy where the destination range is specified
using an insert iterator should be replaced with calls to range member
functions.</li>
<li>Member functions that support ranges:
<ul>
<li>Range construction.</li>
<li>Range insertion.</li>
<li>Range erasure.</li>
<li>Range assignment.</li>
</ul></li>
</ul>
<h3 id="item-6.-be-alert-for-cs-most-vexing-parse.">Item 6. Be alert for
C++'s most vexing parse.</h3>
<ul>
<li><p>Suppose you have a file of ints and you'd like to copy those ints
into a list:</p>
<p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ifstream <span class="title">dataFile</span><span class="params">(<span class="string">&quot;ints.dat&quot;</span>)</span></span>;</span><br><span class="line"><span class="function">list&lt;<span class="type">int</span>&gt; <span class="title">data</span><span class="params">(istream_iterator&lt;<span class="type">int</span>&gt;(dataFile), istream_iterator&lt;<span class="type">int</span>&gt;())</span></span>;</span><br></pre></td></tr></table></figure></p></li>
<li><p>This declares a function, data, whose return type is
list&lt;int&gt;. The function data takes two parameters:</p>
<ul>
<li>The first parameter is named dataFile. It's type is
istream_iterator&lt;int&gt;. The parentheses around dataFile are
superfluous and are ignored.</li>
<li>The second parameter has no name. Its type is pointer to function
taking nothing and returning an istream_iterator&lt;int&gt;.</li>
</ul></li>
<li><p>By adding a pair of parentheses, we force compilers to see things
our way:</p>
<p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// note new parens around first argument to list&#x27;s constructor</span></span><br><span class="line"><span class="function">list&lt;<span class="type">int</span>&gt; <span class="title">data</span><span class="params">((istream_iterator&lt;<span class="type">int</span>&gt;(dataFile)), istream_iterator&lt;<span class="type">int</span>&gt;())</span></span>;</span><br></pre></td></tr></table></figure></p></li>
<li><p>A better solution is to step back from the trendy use of
anonymous istream_iterator objects in data's declaration and simply give
those iterators names:</p>
<p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ifstream <span class="title">dataFile</span><span class="params">(<span class="string">&quot;ints.dat&quot;</span>)</span></span>;</span><br><span class="line"><span class="function">istream_iterator&lt;<span class="type">int</span>&gt; <span class="title">dataBegin</span><span class="params">(dataFile)</span></span>;</span><br><span class="line">istream_iterator&lt;<span class="type">int</span>&gt; dataEnd;</span><br><span class="line"><span class="function">list&lt;<span class="type">int</span>&gt; <span class="title">data</span><span class="params">(dataBegin, dataEnd)</span></span>;</span><br></pre></td></tr></table></figure></p></li>
</ul>
<h3
id="item-7.-when-using-containers-of-newed-pointers-remember-to-delete-the-pointers-before-the-container-is-destroyed.">Item
7. When using containers of newed pointers, remember to delete the
pointers before the container is destroyed.</h3>
<ul>
<li>To avoid resource leaks when you have containers of pointers that
should be deleted, you must either replace the pointers with smart
reference-counting pointer objects (such as Boost's shared_ptr) or you
must manually delete each pointer in the container before the container
is destroyed.</li>
</ul>
<h3 id="item-8.-never-create-containers-of-auto_ptrs.">Item 8. Never
create containers of auto_ptrs.</h3>
<ul>
<li>Containers of auto_ptr (COAPs) aren't portable. The Standard for C++
forbids them, and better STL platforms already enforce this.</li>
<li>When you copy an auto_ptr, ownership of the object pointed to by the
auto_ptr is transferred to the copying auto_ptr, and the copied auto_ptr
is set to NULL.</li>
<li>One or more of the auto_ptrs in the container may have been set to
NULL during quicksort.</li>
</ul>
<h3 id="item-9.-choose-carefully-among-erasing-options.">Item 9. Choose
carefully among erasing options.</h3>
<ul>
<li><strong>To eliminate all objects in a container that have a
particular value:</strong>
<ul>
<li>If the container is a vector, string, or deque, use the erase-remove
idiom.</li>
<li>If the container is a list, use list::remove.</li>
<li>If the container is a standard associative container, use its erase
member function.</li>
</ul></li>
<li><strong>To eliminate all objects in a container that satisfy a
particular predicate:</strong>
<ul>
<li>If the container is a vector, string, or deque, use the
erase-remove_if idiom.</li>
<li>If the container is a list, use list::remove_if.</li>
<li>If the container is a standard associative container, use
remove_copy_if and swap, or write a loop to walk the container elements,
being sure to postincrement your iterator when you pass it to
erase.</li>
</ul></li>
<li><strong>To do something inside the loop (in addition to erasing
objects):</strong>
<ul>
<li>If the container is a standard sequence container, write a loop to
walk the container elements, being sure to update your iterator with
erase's return value each time you call it.</li>
<li>If the container is a standard associative container, write a loop
to walk the container elements, being sure to postincrement your
iterator when you pass it to erase.</li>
</ul></li>
</ul>
<h3
id="item-10.-be-aware-of-allocator-conventions-and-restrictions.">Item
10. Be aware of allocator conventions and restrictions.</h3>
<ul>
<li>Make your allocator a template, with the template parameter T
representing the type of objects for which you are allocating
memory.</li>
<li>Provide the typedefs pointer and reference, but always have pointer
be T* and reference be T&amp;.</li>
<li>Never give your allocators per-object state. In general, allocators
should have no nonstatic data members.</li>
<li>Remember that an allocator's allocate member functions are passed
the number of <strong>objects</strong> for which memory is required, not
the number of bytes needed. Also remember that these functions return T*
pointers via the pointer typedef, even though no T objects have yet been
constructed.</li>
<li>Be sure to provide the nested rebind template on which standard
containers depend.</li>
</ul>
<h3
id="item-11.-understand-the-legitimate-uses-of-custom-allocators.">Item
11. Understand the legitimate uses of custom allocators.</h3>
<ul>
<li>You've benchmarked, profiled, and experimented your way to the
conclusion that the default STL memory manager (i.e.,
allocator&lt;T&gt;) is too slow, wastes memory, or suffers excessive
fragmentation for your STL needs, and you're certain you can do a better
job yourself.</li>
<li>You discover that allocator&lt;T&gt; takes precautions to be
thread-safe, but you're interested only in single-threaded execution and
you don't want to pay for the synchronization overhead you don't
need.</li>
<li>You know that objects in certain containers are typically used
together, so you'd like to place them near one another in a special heap
to maximize locality of reference.</li>
<li>You'd like to set up a unique heap that corresponds to shared
memory, then put one or more containers in that memory so they can be
shared by other processes.</li>
</ul>
<h3
id="item-12.-have-realistic-expectations-about-the-thread-safety-of-stl-containers.">Item
12. Have realistic expectations about the thread safety of STL
containers.</h3>
<ul>
<li><p>The gold standard in support for multithreading in STL
containers:</p>
<ul>
<li><strong>Multiple readers are safe.</strong> Multiple threads may
simultaneously read the contents of a single container, and this will
work correctly. Naturally, there must not be any writers acting on the
container during the reads.</li>
<li><strong>Multiple writers to different containers are safe.</strong>
Multiple threads may simultaneously write to different containers.</li>
</ul>
<p>This is what you can <strong>hope for</strong>, not what you can
<strong>expect</strong>. Some implementations offer these guarantees,
but some do not.</p></li>
<li><p>You <strong>can't</strong> hope for the library to eliminate the
need for manual concurrency control, and you can't <strong>rely</strong>
on any thread support at all.</p></li>
</ul>
<h3
id="item-13.-prefer-vector-and-string-to-dynamically-allocated-arrays.">Item
13. Prefer vector and string to dynamically allocated arrays.</h3>
<ul>
<li>Any time you find yourself getting ready to dynamically allocate an
array (i.e.. plotting to write "new T[...]"), you should consider using
a vector or a string instead.</li>
<li>Only one legitimate cause for concern in replacing dynamically
allocated arrays with vectors or strings, and it applies only to
strings: many string implementations employ reference counting behind
the scenes. If you're using reference-counted strings in a multithreaded
environment, then, it makes sense to keep an eye out for performance
problems arising from their support for thread safety.</li>
<li>If so, you have at least three reasonable choices:
<ul>
<li>Check to see if your library implementation is one that makes it
possible to disable reference counting.</li>
<li>Find or develop an alternative string implementation (or partial
implementation) that doesn't use reference counting.</li>
<li>Consider using a vector&lt;char&gt; instead of a string.</li>
</ul></li>
</ul>
<h3 id="item-14.-use-reserve-to-avoid-unnecessary-reallocations.">Item
14. Use reserve to avoid unnecessary reallocations.</h3>
<ul>
<li>Four interrelated member functions that are sometimes confused:
<ul>
<li>size() tells you how many elements are in the container.</li>
<li>capacity() tells you how many elements the container can hold in the
memory it has already allocated.</li>
<li>resize(size_t n) forces the container to change to n the number of
elements it holds.</li>
<li>reserve(size_t n) forces the container to change its capacity to at
least n, provided n is no less than the current size.</li>
</ul></li>
<li>The reserve member function allows you to minimize the number of
reallocations that must be performed, thus avoiding the costs of
reallocation and iterator/pointer/reference invalidation.</li>
<li>There are two common ways to use reserve to avoid unneeded
reallocations:
<ul>
<li>The first is applicable when you know exactly or approximately how
many elements will ultimately end up in your container. In that case,
you simply reserve the appropriate amount of space in advance.</li>
<li>The second way is to reserve the maximum space you could ever need,
then, once you've added all your data, trim off any excess capacity.
(See Item 17 for the trimming part)</li>
</ul></li>
</ul>
<h3 id="item-15.-be-aware-of-variations-in-string-implementations.">Item
15. Be aware of variations in string implementations.</h3>
<ul>
<li>Virtually every string implementation holds the following
information:
<ul>
<li><strong>The size</strong> of the string, i.e., the number of
characters it contains.</li>
<li><strong>The capacity</strong> of the memory holding the string's
characters.</li>
<li><strong>The value</strong> of the string, i.e., the characters
making up the string.</li>
<li>A copy of its <strong>allocator</strong> (optional).</li>
<li><strong>The reference count</strong> for the value. (For string
implementations that depend on reference counting)</li>
</ul></li>
<li>If you expect to have lots of short strings, either (1) your release
environment has very little memory or (2) you are concerned about
locality of reference and want to cluster strings on as few pages as
possible.</li>
<li>Let's summarize the things that vary:
<ul>
<li>string values may or may not be reference counted. By default, many
implementations do use reference counting, but they usually offer a way
to turn it off, often via a preprocessor macro.</li>
<li>string objects may range in size from one to at least seven times
the size of char* pointers.</li>
<li>Creation of a new string value may require zero, one, or two dynamic
allocations.</li>
<li>string objects may or may not share information on the string's size
and capacity.</li>
<li>strings may or may not support per-object allocators.</li>
<li>Different implementations have different policies regarding minimum
allocations for character buffers.</li>
</ul></li>
</ul>
<h3
id="item-16.-know-how-to-pass-vector-and-string-data-to-legacy-apis.">Item
16. Know how to pass vector and string data to legacy APIs.</h3>
<ul>
<li><p>If you have a vector v and you need to get a pointer to the data
in v that can be viewed as an array, just use &amp;v[0]. For a string s,
the corresponding incantation is simply s.c_str().</p></li>
<li><p>The approach to getting a pointer to container data that works
for vectors isn't reliable for strings, because (1) the data for strings
are not guaranteed to be stored in contiguous memory, and (2) the
internal representation of a string is not guaranteed to end with a null
character.</p></li>
<li><p>string objects don't care if they contain null characters, but
char*-based C APIs do.</p></li>
<li><p>For a string, you can only <strong>read</strong> its data (not
modify it), because there is no guarantee that c_str yields a pointer to
the internal representation of the string data: it could return a
pointer to an unmodifiable copy of the string's data, one that's
correctly formatted for a C API.</p></li>
<li><p>For a vector, you have a little more flexibility. If you pass it
to a C API that modifies its elements, that's <strong>typically</strong>
okay, but the called routine must not attempt to change the number of
elements in the vector. However, some vectors have extra constraints on
their data, and if you pass a vector to an API that modifies the
vector's data, you must ensure that the additional constraints continue
to be satisfied. (e.g. sorted vectors)</p></li>
<li><p>If you have a vector that you'd like to initialize with elements
from a C API, you can take advantage of the underlying layout
compatibility of vectors and arrays by passing to the API the storage
for the vector's elements:</p>
<p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// C API: this function takes a pointer to an array of at most arraySize</span></span><br><span class="line"><span class="comment">// doubles and writes data to it. It returns the number of doubles written,</span></span><br><span class="line"><span class="comment">// which is never more than maxNumDoubles.</span></span><br><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">fillArray</span><span class="params">(<span class="type">double</span> *pArray, <span class="type">size_t</span> arraySize)</span></span>;</span><br><span class="line"><span class="function">vector&lt;<span class="type">double</span>&gt; <span class="title">vd</span><span class="params">(maxNumDoubles)</span></span>;</span><br><span class="line">vd.<span class="built_in">resize</span>(<span class="built_in">fillArray</span>(&amp;vd[<span class="number">0</span>], vd.<span class="built_in">size</span>()));</span><br></pre></td></tr></table></figure></p>
<p>This technique works only for vectors, because only vectors are
guaranteed to have the same underlying memory layout as arrays.</p></li>
<li><p>If you want to initialize a string with data from a C API,
however, you can have the API put the data into a vector&lt;char&gt;,
then copy the data from the vector to the string:</p>
<p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">fillString</span><span class="params">(<span class="type">char</span> *pArray, <span class="type">size_t</span> arraySize)</span></span>;</span><br><span class="line"><span class="function">vector&lt;<span class="type">char</span>&gt; <span class="title">vc</span><span class="params">(maxNumChars)</span></span>;</span><br><span class="line"><span class="type">size_t</span> charsWritten = <span class="built_in">fillString</span>(&amp;vc[<span class="number">0</span>], vc.<span class="built_in">size</span>());</span><br><span class="line"><span class="function">string <span class="title">s</span><span class="params">(vc.begin(), vc.begin() + charsWritten)</span></span>;</span><br></pre></td></tr></table></figure></p></li>
<li><p>In fact, the idea of having a C API put data into a vector and
then copying the data into the STL container you really want it in
always works:</p>
<p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">fillArray</span><span class="params">(<span class="type">double</span> *pArray, <span class="type">size_t</span> arraySize)</span></span>;</span><br><span class="line"><span class="function">vector&lt;<span class="type">double</span>&gt; <span class="title">vd</span><span class="params">(maxNumDoubles)</span></span>;</span><br><span class="line">vd.<span class="built_in">resize</span>(<span class="built_in">fillArray</span>(&amp;vd[<span class="number">0</span>], vd.<span class="built_in">size</span>()));</span><br><span class="line"></span><br><span class="line"><span class="function">deque&lt;<span class="type">double</span>&gt; <span class="title">d</span><span class="params">(vd.begin(), vd.end())</span></span>;</span><br><span class="line"><span class="function">list&lt;<span class="type">double</span>&gt; <span class="title">l</span><span class="params">(vd.begin(), vd.end())</span></span>;</span><br><span class="line"><span class="function">set&lt;<span class="type">double</span>&gt; <span class="title">s</span><span class="params">(vd.begin(), vd.end())</span></span>;</span><br></pre></td></tr></table></figure></p></li>
<li><p>Furthermore, this hints at how STL containers other than vector
or string can pass their data to C APIs. Just copy each container's data
into a vector, then pass it to the API:</p>
<p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">doSomething</span><span class="params">(<span class="type">const</span> <span class="type">int</span>* pints, <span class="type">size_t</span> numlnts)</span></span>;</span><br><span class="line">set&lt;<span class="type">int</span>&gt; intSet;</span><br><span class="line">...</span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">v</span><span class="params">(intSet.begin(), intSet.end())</span></span>;</span><br><span class="line"><span class="keyword">if</span> (!v.<span class="built_in">empty</span>()) <span class="built_in">doSomething</span>(&amp;v[<span class="number">0</span>], v.<span class="built_in">size</span>());</span><br></pre></td></tr></table></figure></p></li>
</ul>
<h3 id="item-17.-use-the-swap-trick-to-trim-excess-capacity.">Item 17.
Use "the swap trick" to trim excess capacity.</h3>
<ul>
<li><p>Calling a range form of erase does a fine job of reducing the
size of the vector, but it does nothing to reduce its capacity.</p></li>
<li><p>"The swap trick" to trim excess capacity (shrink-to-fit):</p>
<p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Contestant</span> &#123;...&#125;;</span><br><span class="line">vector&lt;Contestant&gt; contestants;</span><br><span class="line">...</span><br><span class="line"><span class="built_in">vector</span>&lt;Contestant&gt;(contestants).<span class="built_in">swap</span>(contestants);</span><br></pre></td></tr></table></figure></p>
<p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">string s;</span><br><span class="line">...</span><br><span class="line"><span class="built_in">string</span>(s).<span class="built_in">swap</span>(s);</span><br></pre></td></tr></table></figure></p></li>
<li><p>The language police makes no guarantee that this technique will
truly eliminate excess capacity. Implementers are free to give vectors
and strings excess capacity if they want to, and sometimes they want to.
This approach to "shrink-to-fit," then, doesn't really mean "make the
capacity as small as possible". It means "make the capacity as small as
this implementation is willing to make it given the current size of the
container."</p></li>
<li><p>A variant of the swap trick can be used both to clear a container
and to reduce its capacity to the minimum your implementation offers.
You simply do the swap with a temporary vector or string that is
default-constructed:</p>
<p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;Contestant&gt; v;</span><br><span class="line">string s;</span><br><span class="line">...</span><br><span class="line"><span class="built_in">vector</span>&lt;Contestant&gt;().<span class="built_in">swap</span>(v);</span><br><span class="line"><span class="built_in">string</span>().<span class="built_in">swap</span>(s);</span><br></pre></td></tr></table></figure></p></li>
<li><p>Swapping the contents of two containers also swaps their
iterators, pointers, and references. Iterators, pointers, and references
that used to point to elements in one container remain valid and point
to the same elements — but in the other container— after the
swap.</p></li>
</ul>
<h3 id="item-18.-avoid-using-vectorbool.">Item 18. Avoid using
vector&lt;bool&gt;.</h3>
<ul>
<li>vector&lt;bool&gt; is not an STL container, and it doesn't hold
bools.</li>
<li>vector&lt;bool&gt; is a pseudo-container that contains not actual
bools, but a packed representation of bools that is designed to save
space. In a typical implementation, each "bool" stored in the "vector"
occupies a single bit, and an eight-bit byte holds eight "bools."
Internally, vector&lt;bool&gt; uses the moral equivalent of bitfields to
represent the bools it pretends to be holding.</li>
<li>You may create a pointer to a real bool, but pointers (and
references) to individual bits are forbidden.</li>
<li>vector&lt;bool&gt;::operator[] returns an object that acts
<strong>like a</strong> reference to a bit, a so-called <em>proxy
object</em>.</li>
<li>What should you use when you need a vector&lt;bool&gt;? Two
alternatives suffice almost all the time:
<ul>
<li>deque&lt;bool&gt;, which is an STL container that really contains
bools.</li>
<li>bitset, which isn't an STL container, but is part of the standard
C++ library.</li>
</ul></li>
</ul>
<h3
id="item-19.-understand-the-difference-between-equality-and-equivalence.">Item
19. Understand the difference between equality and equivalence.</h3>
<ul>
<li>The non-member find algorithm's definition of "the same" is
<strong>equality</strong>, which is based on operator==. set::find or
set::insert's definition of "the same" is <strong>equivalence</strong>,
which is usually based on operators.</li>
<li>If the expression "x == y" returns true, x and y have equal values,
otherwise they don't. Just because x and y have equal values does not
necessarily imply that all of their data members have equal values.</li>
<li>Equivalence is based on the relative ordering of object values in a
sorted range. Two objects x and y have equivalent values with respect to
the sort order used by an associative container c if neither precedes
the other in c's sort order.</li>
<li>For <strong>sorted</strong> associative containers, member and
non-member find may return different results.</li>
<li>There are two common designs for nonstandard associative containers
based on hash tables. One design is based on equality, while the other
is based on equivalence.</li>
</ul>
<h3
id="item-20.-specify-comparison-types-for-associative-containers-of-pointers.">Item
20. Specify comparison types for associative containers of
pointers.</h3>
<ul>
<li><p>A standard associative container of pointers will be sorted by
the values of the pointers. Only rarely will this be what you want, so
you'll almost always want to create your own functor class to serve as a
comparison type.</p></li>
<li><p>Most of the time, your comparison type will just dereference the
pointers and compare the pointed-to objects. That being the case, you
might as well keep a template for such comparison functors close at
hand.</p>
<p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">DereferenceLess</span> &#123;</span><br><span class="line">	<span class="keyword">template</span> &lt;<span class="keyword">typename</span> PtrType&gt;</span><br><span class="line">	<span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(PtrType pT1, PtrType pT2)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> *pT1 &lt; *pT2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">set&lt;string*, DereferenceLess&gt; ssp;</span><br></pre></td></tr></table></figure></p></li>
<li><p>This Item is about associative containers of pointers, but it
applies equally well to containers of objects that act like pointers,
e.g., smart pointers and iterators.</p></li>
</ul>
<h3
id="item-21.-always-have-comparison-functions-return-false-for-equal-values.">Item
21. Always have comparison functions return false for equal values.</h3>
<ul>
<li>The return value of a comparison function indicates whether one
value precedes another in the sort order defined by that function. Equal
values never precede one another, so comparison functions should always
return false for equal values, regardless of whether the containers are
allowed to store duplicates.</li>
<li>Technically speaking, comparison functions used to sort associative
containers must define a “strict weak ordering” over the objects they
compare. Any function defining a strict weak ordering must return false
if it's passed two copies of the same value. (Comparison functions
passed to algorithms like sort are similarly constrained.)</li>
</ul>
<h3
id="item-22.-avoid-in-place-key-modification-in-set-and-multiset.">Item
22. Avoid in-place key modification in set and multiset.</h3>
<ul>
<li><p>In-place key modification is impossible for map and multimap
(unless you use a cast), but it may be possible for set and
multiset.</p></li>
<li><p>If portability is not a concern, you want to change the value of
an element in a set or multiset, and your STL implementation will let
you get away with it, go ahead and do it. Just be sure not to change a
key part of the element, i.e., a part of the element that could affect
the sortedness of the container.</p></li>
<li><p>If you value portability, assume that the elements in sets and
multisets cannot be modified, at least not without a cast.</p></li>
<li><p>To change a non-key portion of an element in a set or a multiset
correctly and portably, you must cast to a <strong>reference</strong> to
avoid creating a new object.</p>
<p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> set&lt;Employee, IDNumberLess&gt; EmplDSet;</span><br><span class="line">EmplDSet se;</span><br><span class="line">Employee selectedID;</span><br><span class="line">...</span><br><span class="line">EmplDSet::iterator i = se.<span class="built_in">find</span>(selectedID);</span><br><span class="line"><span class="keyword">if</span> (i != se.<span class="built_in">end</span>()) &#123;</span><br><span class="line">    <span class="built_in">const_cast</span>&lt;Employee&amp;&gt;(*i).<span class="built_in">setTitle</span>(<span class="string">&quot;Corporate Deity&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></li>
<li><p>A map&lt;K, V&gt; or a multimap&lt;K, V&gt; contains elements of
type pair&lt;const K, V&gt;. That const means that the first component
of the pair is defined to be const, and that means that attempts to cast
away its constness are undefined. If you're a stickler for following the
rules laid down by the Standard, you'll never try to cast away the
constness of a map or multimap key.</p></li>
<li><p>If you want to change an element in a set, multiset, map, or
multimap in a way that always works and is always safe, do it in five
simple steps:</p>
<ol type="1">
<li>Locate the container element you want to change.</li>
<li>Make a copy of the element to be modified. In the case of a map or
multimap, be sure not to declare the first component of the copy const.
After all, you want to change it!</li>
<li>Remove the element from the container, typically via a call to
erase.</li>
<li>Modify the copy so it has the value you want to be in the
container.</li>
<li>Insert the new value into the container. If the location of the new
element in the container's sort order is likely to be the same or
adjacent to that of the removed element, use the "hint" form of insert
to improve the efficiency of the insertion from logarithmic-time to
constant-time. Use the iterator you got from Step 1 as the hint.</li>
</ol>
<p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">EmplDSet se;</span><br><span class="line">Employee selectedID;</span><br><span class="line">...</span><br><span class="line">EmplDSet::iterator i = se.<span class="built_in">find</span>(selectedID);</span><br><span class="line"><span class="keyword">if</span> (i != se.<span class="built_in">end</span>()) &#123;</span><br><span class="line">    <span class="function">Employee <span class="title">e</span><span class="params">(*i)</span></span>;</span><br><span class="line">    se.<span class="built_in">erase</span>(i++);</span><br><span class="line">	e.<span class="built_in">setTitle</span>(<span class="string">&quot;Corporate Deity&quot;</span>);</span><br><span class="line">	se.<span class="built_in">insert</span>(i, e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></li>
</ul>
<h3
id="item-23.-consider-replacing-associative-containers-with-sorted-vectors.">Item
23. Consider replacing associative containers with sorted vectors.</h3>
<ul>
<li><p>The standard associative containers are typically implemented as
balanced binary search trees. A balanced binary search tree is a data
structure that is optimized for a mixed combination of insertions,
erasures, and lookups.</p></li>
<li><p>Many applications use their data structures in a less chaotic
manner, which falls into three distinct phases:</p>
<ol type="1">
<li>Setup</li>
<li>Lookup</li>
<li>Reorganize</li>
</ol>
<p>where lookups are almost never mixed with insertions and erasures.
For these applications, a sorted vector working with lookup algorithms
is likely to offer better performance (in both time and space) than an
associative container.</p></li>
<li><p>Storing data in a sorted vector is likely to consume less memory
than storing the same data in a standard associative container, and
searching a sorted vector via binary search is likely to be faster than
searching a standard associative container when page faults are taken
into account.</p></li>
<li><p>When using a vector to emulate a map&lt;K, V&gt;, then:</p>
<ul>
<li>The type of the data stored in the vector will be pair&lt;K, V&gt;,
not pair&lt;const K, V&gt;, because when you sort the vector, the values
of its elements will get moved around via assignment, and that means
that both components of the pair must be assignable.</li>
<li>maps and multimaps keep their elements in sorted order only by the
key part of the element (the first component of the pair), and you must
do the same when sorting a vector. You'll need to write a custom
comparison function for your pairs, because pair's operator&lt; looks at
both components of the pair.</li>
<li>You'll need a second comparison function for performing lookups,
which must take an object of the key type (the value being searched for)
and a pair (one of the pairs stored in the vector) — two different
types. As an additional twist, you can't know whether the key value or
the pair will be passed as the first argument, so you really need two
comparison functions for lookups: one where the key value is passed
first and one where the pair is passed first.</li>
</ul>
<p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> pair&lt;string, <span class="type">int</span>&gt; Data;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DataCompare</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> Data&amp; lhs, <span class="type">const</span> Data&amp; rhs)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">keyLess</span>(lhs.first, rhs.first);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> Data&amp; Ihs, <span class="type">const</span> Data::first_type&amp; k)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">keyLess</span>(lhs.first, k);</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> Data::first_type&amp; k, <span class="type">const</span> Data&amp; rhs)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">keyLess</span>(k, rhs.first);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="function"><span class="type">bool</span> <span class="title">keyLess</span><span class="params">(<span class="type">const</span> Data::first_type&amp; k1, <span class="type">const</span> Data::first_type&amp; k2)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> k1 &lt; k2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p></li>
</ul>
<h3
id="item-24.-choose-carefully-between-mapoperator-and-map-insert-when-efficiency-is-important.">Item
24. Choose carefully between map::operator[] and map-insert when
efficiency is important.</h3>
<ul>
<li><p>map::operator[] is designed to facilitate "add or update"
functionality.</p></li>
<li><p>When an "add" is performed, insert is more efficient than
operator[].</p></li>
<li><p>When an "update" is performed, the situation is
reversed.</p></li>
<li><p>A function that offers efficient add-or-update functionality in a
syntactically attractive package:</p>
<p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> MapType, <span class="keyword">typename</span> KeyArgType, <span class="keyword">typename</span> ValueArgtype&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">typename</span> MapType::iterator</span></span><br><span class="line"><span class="function"><span class="title">efficientAddOrUpdate</span><span class="params">(MapType&amp; m, <span class="type">const</span> KeyArgType&amp; k, <span class="type">const</span> ValueArgtype&amp; v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">typename</span> MapType::iterator lb = m.<span class="built_in">lower_bound</span>(k);</span><br><span class="line">    <span class="keyword">if</span> (lb != m.<span class="built_in">end</span>() &amp;&amp; !(m.<span class="built_in">key_comp</span>()(k, lb-&gt;first))) &#123;</span><br><span class="line">        lb-&gt;second = v;</span><br><span class="line">        <span class="keyword">return</span> lb;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">typedef</span> <span class="keyword">typename</span> MapType::value_type MVT;</span><br><span class="line">        <span class="keyword">return</span> m.<span class="built_in">insert</span>(lb, <span class="built_in">MVT</span>(k, v)); <span class="comment">// insert with hint, in constant time</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></li>
</ul>
<h3
id="item-25.-familiarize-yourself-with-the-nonstandard-hashed-containers.">Item
25. Familiarize yourself with the nonstandard hashed containers.</h3>
<ul>
<li>Though the STL itself lacks hashed containers. STL-compatible hashed
containers (with varying interfaces, capabilities, and behavioral
trade-offs) are not difficult to come by. (e.g. SGI and Dinkumware)</li>
</ul>
<h3
id="item-26.-prefer-iterator-to-const-iterator-reverse_iterator-and-const_reverse_iterator.">Item
26. Prefer iterator to const iterator, reverse_iterator, and
const_reverse_iterator.</h3>
<ul>
<li><p>This diagram displays the conversions that exist among iterator
types:</p>
<p><img data-src="https://ipichub.oss-cn-hangzhou.aliyuncs.com/2022-07-09-083816.png" style="zoom:50%;" /></p></li>
<li><p>Why it often makes sense to prefer iterators to const and reverse
iterators:</p>
<ul>
<li>Some versions of insert and erase require iterators. If you want to
call those functions, you're going to have to produce iterators, const
and reverse iterators won't do.</li>
<li>It's not possible to implicitly convert a const iterator to an
iterator, and the technique for generating an iterator from a
const_iterator is neither universally applicable nor guaranteed to be
efficient.</li>
<li>Conversion from a reverse_iterator to an iterator may require
iterator adjustment after the conversion.</li>
</ul></li>
<li><p>Stay away from const_iterators to avoid potential implementation
shortcomings when mixing iterators and const_iterators (or
reverse_iterators and const_reverse_iterators) in the same
expression.</p></li>
</ul>
<h3
id="item-27.-use-distance-and-advance-to-convert-a-containers-const_iterators-to-iterators.">Item
27. Use distance and advance to convert a container's const_iterators to
iterators.</h3>
<ul>
<li><p>For deque, list, set, multiset, map, multimap and hashed
containers, const_iterators can't be cast to iterators because they are
different classes.</p></li>
<li><p>The cast <strong>might</strong> compile if the iterators'
container were a vector or a string, because it is common for
implementations of these containers to use pointers as iterators.
However, its portability is doubtful, so casting const iterators to
iterators is still ill-advised even for vector and string.</p></li>
<li><p>If you have access to the container a const_iterator came from,
there is a safe, portable way to get its corresponding iterator, and it
involves no circumvention of the type system: create a new iterator at
the beginning of the container, then move it forward it until it's as
far from the beginning of the container as the const_iterator is.</p>
<p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> deque&lt;<span class="type">int</span>&gt; IntDeque;</span><br><span class="line"><span class="keyword">typedef</span> IntDeque::iterator Iter;</span><br><span class="line"><span class="keyword">typedef</span> IntDeque::const_iterator Constlter;</span><br><span class="line">IntDeque d;</span><br><span class="line">Constlter ci;</span><br><span class="line">...                <span class="comment">// make ci point into d</span></span><br><span class="line"><span class="function">Iter <span class="title">i</span><span class="params">(d.begin())</span></span>;</span><br><span class="line"><span class="built_in">advance</span>(i, <span class="built_in">distance</span>&lt;ConstIter&gt;(i, ci)); <span class="comment">// explicitly specify the type parameter</span></span><br></pre></td></tr></table></figure></p></li>
<li><p>This technique is as efficient as the iterators allow it to be.
For random access iterators (such as those sported by vector, string,
and deque), it's a constant-time operation. For bidirectional iterators
(i.e., those for all other standard containers and for some
implementations of the hashed containers), it's a linear-time
operation.</p></li>
</ul>
<h3
id="item-28.-understand-how-to-use-a-reverse_iterators-base-iterator.">Item
28. Understand how to use a reverse_iterator's base iterator.</h3>
<ul>
<li><p>This picture displays the characteristic offset of a
reverse_iterator and its corresponding base iterator that mimics the
offset of rbegin() and rend() with respect to begin() and end():</p>
<p><img data-src="https://ipichub.oss-cn-hangzhou.aliyuncs.com/2022-07-09-084208.png" style="zoom:50%;" /></p></li>
<li><p>To emulate insertion at a position specified by a
reverse_iterator ri, insert at the position ri.base() instead. For
purposes of insertion, ri and ri.base() are equivalent, and ri.base() is
truly the iterator corresponding to ri.</p></li>
<li><p>To emulate erasure at a position specified by a reverse_iterator
ri, erase at the position preceding ri.base() instead. For purposes of
erasure, ri and ri.base() are nor equivalent, and ri.base() is nor the
iterator corresponding to ri.</p>
<p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; v;</span><br><span class="line">...                                 <span class="comment">// put 1 -5 in v</span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt;::reverse_iterator ri =  <span class="comment">// make ri point to the 3</span></span><br><span class="line">    <span class="built_in">find</span>(v.<span class="built_in">rbegin</span>(), v.<span class="built_in">rend</span>(), <span class="number">3</span>);</span><br><span class="line">v.<span class="built_in">erase</span>((++ri).<span class="built_in">base</span>());             <span class="comment">// erase the element pointed to by ri</span></span><br></pre></td></tr></table></figure></p></li>
</ul>
<h3
id="item-29.-consider-istreambuf_iterators-for-character-by-character-input.">Item
29. Consider istreambuf_iterators for character-by-character input.</h3>
<ul>
<li><p>istream_iterators use operator&lt;&lt; functions to do the actual
reading, which skip whitespace by default, and must undertake a fair
amount of work to perform formatted input.</p></li>
<li><p>If you need to read the characters in a stream one by one, you
don't need the power of formatted input, and you care about how long it
takes to read the stream, typing three extra characters per iterator is
a small price to pay for what is often a significant increase in
performance. For unformatted character-by-character input, you should
always consider istreambuf_iterators.</p>
<p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ifstream <span class="title">inputFile</span><span class="params">(<span class="string">&quot;interestingData.txt&quot;</span>)</span></span>;</span><br><span class="line"><span class="function">string <span class="title">fileData</span><span class="params">((istreambuf_iterator&lt;<span class="type">char</span>&gt;(inputFile)), istreambuf_iterator&lt;<span class="type">char</span>&gt;())</span></span>;</span><br></pre></td></tr></table></figure></p></li>
<li><p>You should also consider ostreambuf_iterators for the
corresponding unformatted character-by-character output operations. They
avoid the overhead (and flexibility) of their ostream_iterator cousins,
so they generally outperform them, too.</p></li>
</ul>
<h3 id="item-30.-make-sure-destination-ranges-are-big-enough.">Item 30.
Make sure destination ranges are big enough.</h3>
<ul>
<li><p>Internally, the iterator returned by back_inserter causes
push_back to be called, so you may use back_inserter with any container
offering push_back (i.e., any of the standard sequence containers:
vector, string, deque, and list).</p></li>
<li><p>If you'd prefer to have an algorithm insert things at the front
of a container you can use front_inserter. Internally, front_inserter
makes use of push_front, so front_inserter works only for the containers
offering that member function (i.e. deque and list).</p></li>
<li><p>If you want transform to put its output at the front of results,
but you also want the output to be in the same order as the
corresponding objects in values, just iterate over values in reverse
order:</p>
<p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">transmogrify</span><span class="params">(<span class="type">int</span> x)</span></span>;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; values;</span><br><span class="line">...</span><br><span class="line">list&lt;<span class="type">int</span>&gt; results;</span><br><span class="line"><span class="built_in">transform</span>(values.<span class="built_in">rbegin</span>(), values.<span class="built_in">rend</span>(),</span><br><span class="line">          <span class="built_in">front_inserter</span>(results),</span><br><span class="line">          transmogrify);</span><br></pre></td></tr></table></figure></p></li>
<li><p>inserter allows you to force algorithms to insert their results
into containers at arbitrary locations.</p></li>
<li><p>Regardless of whether you use back_inserter, front_inserter, or
inserter, each insertion into the destination range is done one object
at a time. Item 5 explains that this can be expensive for
contiguous-memory containers (vector, string, and deque), but Item 5's
suggested solution (using range member functions) can't be applied when
it's an algorithm doing the inserting.</p></li>
<li><p>When the container into which you're inserting is a vector or a
string, you can minimize the expense by following the advice of Item 14
and calling reserve in advance.</p></li>
<li><p>Using reserve without also using an insert iterator leads to
undefined behavior inside algorithms as well as to corrupted
containers.</p></li>
<li><p>If you want to overwrite the values of existing container
elements instead of inserting new ones, you don't need an insert
iterator, but you still need to follow the advice of this Item and make
sure your destination range is big enough.</p></li>
</ul>
<h3 id="item-31.-know-your-sorting-options.">Item 31. Know your sorting
options.</h3>
<ul>
<li>If you need to perform a full sort on a vector, string, deque, or
array, you can use sort or stable_sort.</li>
<li>If you have a vector, string, deque, or array and you need to put
only the top n elements in order, partial_sort is available.</li>
<li>If you have a vector, string, deque, or array and you need to
identify the element at position n or you need to identify the top n
elements without putting them in order, nth_element is at your beck and
call.</li>
<li>If you need to separate the elements of a standard sequence
container or an array into those that do and do not satisfy some
criterion, you're probably looking for partition or
stable_partition.</li>
<li>If your data is in a list, you can use partition and
stable_partition directly, and you can use list-sort in place of sort
and stable_sort. If you need the effects offered by partial_sort or
nth_element, you'll have to approach the task indirectly, but there are
a number of options:
<ul>
<li>Copy the elements into a container with random access iterators,
then apply the desired algorithm to that.</li>
<li>Create a container of list::iterators, use the algorithm on that
container, then access the list elements via the iterators.</li>
<li>Use the information in an ordered container of iterators to
iteratively splice the list's elements into the positions you'd like
them to be in.</li>
</ul></li>
<li>In addition, you can keep things sorted at all times by storing your
data in a standard associative container. You might also consider the
standard non-STL container priority_queue, which also keeps its elements
ordered all the time.</li>
<li>Broadly speaking, algorithms that do more work take longer to do it,
and algorithms that must sort stably take longer than algorithms that
can ignore stability. We can order the algorithms we've discussed in
this Item as follows, with algorithms that tend to use fewer resources
(time and space) listed before those that require more:
<ol type="1">
<li>partition</li>
<li>stable_partition</li>
<li>nth_element</li>
<li>partial_sort</li>
<li>sort</li>
<li>stable_sort</li>
</ol></li>
<li>Make your selection based on what you need to accomplish, not on
performance considerations. If you choose an algorithm that does only
what you need to do (e.g., a partition instead of a full sort), you're
likely to end up with code that's not only the clearest expression of
what you want to do, it's also the most efficient way to accomplish it
using the STL.</li>
</ul>
<h3
id="item-32.-follow-remove-like-algorithms-by-erase-if-you-really-want-to-remove-something.">Item
32. Follow remove-like algorithms by erase if you really want to remove
something.</h3>
<ul>
<li><p>Because the only way to eliminate an element from a container is
to invoke a member function on that container, and because remove cannot
know the container holding the elements on which it is operating, it is
not <strong>possible for remove to eliminate elements from a
container</strong>. Removeing elements from a container never changes
the number of elements in the container.</p></li>
<li><p>remove moves elements in the range it's given until all the
"unremoved" elements are at the front of the range (in the same relative
order they were in originally). It returns an iterator pointing one past
the last "unremoved" element.</p></li>
<li><p>remove doesn't change the order of the elements in a range so
that all the "removed" ones are at the end, it arranges for all the
"unremoved" values to be at the beginning. Though the Standard doesn't
require it, the elements beyond the new logical end of the range
typically <strong>retain their old values</strong>.</p></li>
<li><p>You should follow remove by erase if you really want to remove
something.</p>
<p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; v;</span><br><span class="line">v.<span class="built_in">erase</span>(<span class="built_in">remove</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="number">99</span>), v.<span class="built_in">end</span>());</span><br></pre></td></tr></table></figure></p></li>
<li><p>remove and erase are so closely allied, the two are merged in the
list member function remove. This is the only function in the STL named
remove that eliminates elements from a container.</p></li>
<li><p>There are two other "remove-like" algorithms: remove_if and
unique.</p></li>
</ul>
<h3
id="item-33.-be-wary-of-remove-like-algorithms-on-containers-of-pointers.">Item
33. Be wary of remove-like algorithms on containers of pointers.</h3>
<ul>
<li><p>You should try to avoid using remove and similar algorithms
(i.e., remove_if and unique) on containers of dynamically allocated
pointers, because it will lead to resource leak. In many cases, you'll
find that the partition algorithm is a reasonable alternative.</p></li>
<li><p>If you can't avoid using remove on such containers, one way to
eliminate this problem is to delete the pointers and set them to null
prior to applying the erase-remove idiom, then eliminate all the null
pointers in the container:</p>
<p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">delAndNullifyUncertified</span><span class="params">(Widget*&amp; pWidget)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (!pWidget-&gt;<span class="built_in">isCertified</span>()) &#123;</span><br><span class="line">        <span class="keyword">delete</span> pWidget;</span><br><span class="line">        pWidget = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">for_each(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), delAndNullifyUncertified);</span><br><span class="line"><span class="comment">// 0 must be cast to a ptr so C++ correctly deduces the type of remove&#x27;s 3rd param</span></span><br><span class="line">v.<span class="built_in">erase</span>(<span class="built_in">remove</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="built_in">static_cast</span>&lt;Widget*&gt;(<span class="number">0</span>)), v.<span class="built_in">end</span>());</span><br></pre></td></tr></table></figure></p></li>
<li><p>If you're willing to replace the container of pointers with a
container of smart pointers that perform reference counting, the
remove-related difficulties wash away, and you can use the erase-remove
idiom directly.</p></li>
</ul>
<h3 id="item-34.-note-which-algorithms-expect-sorted-ranges.">Item 34.
Note which algorithms expect sorted ranges.</h3>
<ul>
<li><p>Algorithms that require the data on which they operate to be
sorted:</p>
<ul>
<li><strong>binary_search, lower_bound, upper_bound,
equal_range:</strong> promise logarithmic-time lookup only when they are
passed random access iterators.</li>
<li><strong>set_union, set_intersection, set_difference,
set_symmetric_difference:</strong> offer linear-time performance of the
set-theoretical operations their names suggest.</li>
<li><strong>merge, inplace_merge:</strong> perform a single pass of the
mergesort algorithm in linear time.</li>
<li><strong>includes:</strong> determines whether all the objects in one
range are also in another range in linear time.</li>
</ul></li>
<li><p>Algorithms that are typically used with sorted ranges though
don't require them:</p>
<ul>
<li><p><strong>unique, unique_copy:</strong> eliminates all but the
first element from every consecutive group of equal elements.</p>
<blockquote>
<p>In practice, unique is usually employed to eliminate all duplicate
values from a range, so you'll almost always want to make sure that the
range you pass unique (or unique_copy) is sorted.</p>
</blockquote></li>
</ul></li>
<li><p>Because the STL allows you to specify comparison functions to be
used during sorting, different ranges may be sorted in different ways.
If you pass a sorted range to an algorithm that also takes a comparison
function, be sure that the comparison function you pass behaves the same
as the one you used to sort the range.</p>
<p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; v;</span><br><span class="line">...</span><br><span class="line"><span class="built_in">sort</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="built_in">greater</span>&lt;<span class="type">int</span>&gt;());</span><br><span class="line">...</span><br><span class="line"><span class="type">bool</span> a5Exists = <span class="built_in">binary_search</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="number">5</span>, <span class="built_in">greater</span>&lt;<span class="type">int</span>&gt;());</span><br></pre></td></tr></table></figure></p></li>
<li><p>All the algorithms that require sorted ranges determine whether
two values are "the same" by using equivalence, just like the standard
associative containers. In contrast, the default way in which unique and
unique_copy determine whether two objects are "the same" is by using
equality, though you can override this default by passing these
algorithms a predicate defining an alternative definition of "the
same."</p></li>
</ul>
<h3
id="item-35.-implement-simple-case-insensitive-string-comparisons-via-mismatch-or-lexicographical-compare.">Item
35. Implement simple case-insensitive string comparisons via mismatch or
lexicographical compare.</h3>
<ul>
<li><p>Programmers desiring case-insensitive string comparisons often
need two different calling interfaces, one similar to strcmp (which
returns a negative number, zero, or a positive number), the other akin
to operators (which returns true or false).</p></li>
<li><p>First, we need a way to determine whether two characters are the
same, except for their case.</p>
<p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">ciCharCompare</span><span class="params">(<span class="type">char</span> c1, <span class="type">char</span> c2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// cast to ensure the value representable as an unsigned char</span></span><br><span class="line">    <span class="type">int</span> lc1 = <span class="built_in">tolower</span>(<span class="built_in">static_cast</span>&lt;<span class="type">unsigned</span> <span class="type">char</span>&gt;(c1));</span><br><span class="line">    <span class="type">int</span> lc2 = <span class="built_in">tolower</span>(<span class="built_in">static_cast</span>&lt;<span class="type">unsigned</span> <span class="type">char</span>&gt;(c2));</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (lc1 &lt; lc2) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span> (lc1 &gt; lc2) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></li>
<li><p>The first case-insensitive string comparison function offering a
strcmp-like interface, which is built around the mismatch algorithm:</p>
<p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">ciStringCompareImpl</span><span class="params">(<span class="type">const</span> string&amp; si, <span class="type">const</span> strings s2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">typedef</span> pair&lt;string::const_iterator, string::const_iterator&gt; PSCI;</span><br><span class="line">    PSCI p = <span class="built_in">mismatch</span>(</span><br><span class="line">        s1.<span class="built_in">begin</span>(), s1.<span class="built_in">end</span>(),</span><br><span class="line">        s2.<span class="built_in">begin</span>(),</span><br><span class="line">        <span class="built_in">not2</span>(<span class="built_in">ptr_fun</span>(ciCharCompare))); <span class="comment">// return true when the characters match</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (p.first == s1.<span class="built_in">end</span>()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (p.second == s2.<span class="built_in">end</span>()) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">ciCharCompare</span>(*p.first, *p.second);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">ciStringCompare</span><span class="params">(<span class="type">const</span> string&amp; s1, <span class="type">const</span> string&amp; s2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (s1.<span class="built_in">size</span>() &lt;= s2.<span class="built_in">size</span>())</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">ciStringCompareImpl</span>(s1, s2);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> -<span class="built_in">ciStringCompareImpl</span>(s2, s1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></li>
<li><p>The second approach to ciStringCompare yields a conventional STL
predicate, which could be used as a comparison function in associative
containers:</p>
<p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">ciCharLess</span><span class="params">(<span class="type">char</span> c1, <span class="type">char</span> c2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">tolower</span>(<span class="built_in">static_cast</span>&lt;<span class="type">unsigned</span> <span class="type">char</span>&gt;(c1)) &lt;</span><br><span class="line">        <span class="built_in">tolower</span>(<span class="built_in">static_cast</span>&lt;<span class="type">unsigned</span> <span class="type">char</span>&gt;(c2));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">ciStringCompare</span><span class="params">(<span class="type">const</span> string&amp; s1, <span class="type">const</span> string&amp; s2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">lexicographical_compare</span>(s1.<span class="built_in">begin</span>(), s1.<span class="built_in">end</span>(),</span><br><span class="line">                                   s2.<span class="built_in">begin</span>(), s2.<span class="built_in">end</span>(),</span><br><span class="line">                                   ciCharLess);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></li>
<li><p>If you're willing to sacrifice some portability, you know that
your strings never contain embedded nulls, and you don't care about
internationalization, you may find that the easiest way to implement a
case-insensitive string comparison doesn't use the STL at all. Instead,
it converts both strings to const char* pointers and then uses stricmp
or strcmpi on the pointers:</p>
<p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">ciStringCompare</span><span class="params">(<span class="type">const</span> string&amp; s1, <span class="type">const</span> string&amp; s2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">stricmp</span>(s1.<span class="built_in">c_str</span>(), s2.<span class="built_in">c_str</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>stricmp/strcmpi, being optimized to do exactly one thing, typically
run much faster on long strings than do the general-purpose algorithms
mismatch and lexicographical_compare.</p></li>
</ul>
<h3 id="item-36.-understand-the-proper-implementation-of-copy_if.">Item
36. Understand the proper implementation of copy_if.</h3>
<ul>
<li><p>There is no copy_if in the STL. If you simply want to copy the
elements of a range that satisfy a predicate, you're on your
own.</p></li>
<li><p>If copy_if existed, you could simply do this:</p>
<p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isDefective</span><span class="params">(<span class="type">const</span> Widget&amp; w)</span></span>;</span><br><span class="line"></span><br><span class="line">vector&lt;Widget&gt; widgets;</span><br><span class="line">...</span><br><span class="line"><span class="built_in">copy_if</span>(widgets.<span class="built_in">begin</span>(), widgets.<span class="built_in">end</span>(),</span><br><span class="line">        <span class="built_in">ostream_iterator</span>&lt;Widget&gt;(cerr, <span class="string">&quot;\n&quot;</span>),</span><br><span class="line">        isDefective);</span><br></pre></td></tr></table></figure></p></li>
<li><p>A trivial implementation of copy_if:</p>
<p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Inputlterator, <span class="keyword">typename</span> Outputlterator, <span class="keyword">typename</span> Predicate&gt;</span></span><br><span class="line"><span class="function">Outputlterator <span class="title">copy_if</span><span class="params">(Inputlterator begin,</span></span></span><br><span class="line"><span class="params"><span class="function">                       Inputlterator end,</span></span></span><br><span class="line"><span class="params"><span class="function">                       Outputlterator destBegin,</span></span></span><br><span class="line"><span class="params"><span class="function">                       Predicate p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (begin != end) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">p</span>(*begin)) *destBegin++ = *begin;</span><br><span class="line">        ++begin;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> destBegin;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></li>
</ul>
<h3 id="item-37.-use-accumulate-or-for_each-to-summarize-ranges.">Item
37. Use accumulate or for_each to summarize ranges.</h3>
<ul>
<li><p>Accumulate exists in two forms. The form taking a pair of
iterators and an initial value returns the initial value plus the sum of
the values in the range demarcated by the iterators:</p>
<p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">list&lt;<span class="type">double</span>&gt; ld;</span><br><span class="line">...</span><br><span class="line"><span class="type">double</span> sum = <span class="built_in">accumulate</span>(ld.<span class="built_in">begin</span>(), ld.<span class="built_in">end</span>(), <span class="number">0.0</span>); <span class="comment">// initial value must be 0.0, not 0</span></span><br></pre></td></tr></table></figure></p>
<p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cout &lt;&lt; <span class="string">&quot;The sum of the ints on the standard input is&quot;</span></span><br><span class="line">    &lt;&lt; <span class="built_in">accumulate</span>(<span class="built_in">istream_iterator</span>&lt;<span class="type">int</span>&gt;(cin),</span><br><span class="line">                  <span class="built_in">istream_iterator</span>&lt;<span class="type">int</span>&gt;(),</span><br><span class="line">                  <span class="number">0</span>);</span><br></pre></td></tr></table></figure></p></li>
<li><p>When accumulate is used in its alternate form, one taking an
initial summary value and an arbitrary summarization function, it
becomes much more general:</p>
<p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">string::size_type <span class="title">stringLengthSum</span><span class="params">(string::size_type sumSoFar, <span class="type">const</span> string&amp; s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> sumSoFar + s.<span class="built_in">size</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">set&lt;string&gt; ss;</span><br><span class="line">...</span><br><span class="line">string::size_type lengthSum = <span class="built_in">accumulate</span>(ss.<span class="built_in">begin</span>(), ss.<span class="built_in">end</span>(), <span class="number">0</span>, stringLengthSum);</span><br></pre></td></tr></table></figure></p>
<p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="type">float</span>&gt; vf;</span><br><span class="line">...</span><br><span class="line"><span class="type">float</span> product = <span class="built_in">accumulate</span>(vf.<span class="built_in">begin</span>(), vf.<span class="built_in">end</span>(), <span class="number">1.0</span>, <span class="built_in">multiplies</span>&lt;<span class="type">float</span>&gt;());</span><br></pre></td></tr></table></figure></p></li>
<li><p>Like accumulate, for_each takes a range and a function (typically
a function object) to invoke on each element of the range, but the
function passed to for_each receives only a single argument (the current
range element), and for_each returns its function when it's done.
Significantly, the function passed to (and later returned from) for_each
may have side effects.</p>
<p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Point</span> &#123;</span><br><span class="line">	<span class="built_in">Point</span>(<span class="type">double</span> initX, <span class="type">double</span> initY) : <span class="built_in">x</span>(initX), <span class="built_in">y</span>(initY) &#123;&#125;</span><br><span class="line">    <span class="type">double</span> x, y;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">PointAverage</span> : <span class="keyword">public</span> unary_function&lt;Point, <span class="type">void</span>&gt; &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">PointAverage</span>() : <span class="built_in">xSum</span>(<span class="number">0</span>), <span class="built_in">ySum</span>(<span class="number">0</span>), <span class="built_in">numPoints</span>(<span class="number">0</span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> Point&amp; p)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        ++numPoints;</span><br><span class="line">        xSum += p.x;</span><br><span class="line">        ySum += p.y;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">Point <span class="title">result</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Point</span>(xSum/numPoints, ySum/numPoints);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">size_t</span> numPoints;</span><br><span class="line">    <span class="type">double</span> xSum;</span><br><span class="line">    <span class="type">double</span> ySum;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">list&lt;Point&gt; lp;</span><br><span class="line">...</span><br><span class="line">Point avg = for_each(lp.<span class="built_in">begin</span>(), lp.<span class="built_in">end</span>(), <span class="built_in">PointAverage</span>()).<span class="built_in">result</span>();</span><br></pre></td></tr></table></figure></p></li>
<li><p>For summarizing, accumulate most clearly expresses what is going
on, but for_each works, too, and the issue of side effects doesn't dog
for_each as it does accumulate. Both algorithms can be used to summarize
ranges. Use the one that suits you best.</p></li>
</ul>
<h3 id="item-38.-design-functor-classes-for-pass-by-value.">Item 38.
Design functor classes for pass-by-value.</h3>
<ul>
<li>The standard libraries for both C and C++ follow the rule that
function pointers are passed by value. STL function objects are modeled
after function pointers, so the convention in the STL is that function
objects, too, are passed by value (i.e.. copied) when passed to and from
functions.</li>
<li>Make sure that your function objects behave well when passed and
returned by value:
<ul>
<li>First, your function objects need to be small. Otherwise they will
be too expensive to copy.</li>
<li>Second, your function objects must be monomorphic (i.e., not
polymorphic) — they must not use virtual functions.</li>
</ul></li>
<li>There's a way to let function objects be big and/or polymorphic:
take the data and/or the polymorphism you'd like to put in your functor
class, and move it into a different class, then give your functor class
a pointer to this new class.</li>
<li>Functor classes using this technique must support copying in a
reasonable fashion. Perhaps the simplest reasonable thing would be to
reference count it, using something like Boost's shared_ptr.</li>
</ul>
<h3 id="item-39.-make-predicates-pure-functions.">Item 39. Make
predicates pure functions.</h3>
<ul>
<li>Declare your operator() functions const in predicate classes. If you
do that, your compilers won't let you change any class data members.
This is necessary, but not sufficient.</li>
<li>Even const member functions may access mutable data members,
non-const local static objects, non-const class static objects,
non-const objects at namespace scope, and non-const global objects. A
well-designed predicate class ensures that its operator() functions are
independent of those kinds of objects, too.</li>
<li>Functions in predicate classes should be pure functions. This
restriction extends to predicate functions, too.</li>
</ul>
<h3 id="item-40.-make-functor-classes-adaptable.">Item 40. Make functor
classes adaptable.</h3>
<ul>
<li><p>The only thing ptr_fun does is make some typedefs available,
which are required by not1, and that's why applying not1 to ptr_fun
works, but applying not1 to isInteresting directly doesn't work. Being a
lowly function pointer, isInteresting lacks the typedefs that not1
demands.</p>
<p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">list&lt;Widget*&gt; widgetPtrs;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isInteresting</span><span class="params">(<span class="type">const</span> Widget *pw)</span></span>;</span><br><span class="line"></span><br><span class="line">list&lt;Widget*&gt;::iterator i =</span><br><span class="line">    <span class="built_in">find_if</span>(widgetPtrs.<span class="built_in">begin</span>(), widgetPtrs.<span class="built_in">end</span>(),</span><br><span class="line">            <span class="built_in">not1</span>(<span class="built_in">ptr_func</span>(isInteresting)));</span><br><span class="line"><span class="keyword">if</span> (i != widgetPtrs.<span class="built_in">end</span>()) &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></li>
<li><p>Each of the four standard function adapters (not1, not2, bind1st,
and bind2nd) requires the existence of certain typedefs, as do any
non-standard STL-compatible adapters written by others.</p></li>
<li><p>Function objects that provide the necessary typedefs are said to
be <em>adaptable</em>, while function objects lacking these typedefs are
not adaptable. Adaptable function objects can be used in more contexts
than can function objects that are not adaptable, so you should make
your function objects adaptable whenever you can.</p></li>
<li><p>The typedefs in question are argument_type, first_argument_type,
second_argument_type, and result_type. The conventional way to provide
them is to inherit them from a base struct.</p>
<ul>
<li>For functor classes whose operator() takes one argument, the struct
to inherit from is std::unary_function.</li>
<li>For functor classes whose operator() takes two arguments, the struct
to inherit from is std::binary_function.</li>
</ul></li>
<li><p>unary_function and binary_function are templates, you must
inherit from structs they generate.</p>
<ul>
<li>For unary_function, specify the type of parameter taken by your
functor class's operator(), as well as its return type.</li>
<li>For binary_function, specify the types of your operator's first and
second parameters, and your operator's return type.</li>
</ul></li>
<li><p>In general, non-pointer types passed to unary_function or
binary_function have consts and references stripped off. For functor
classes taking or returning pointers, pass to unary_function or
binary_function whatever types operator() takes or returns.</p></li>
<li><p>Sometimes it makes sense to give a functor class multiple
invocation forms (thereby abandoning adaptability). Such functor classes
are the exception, however, not the rule. Adaptability is important, and
you should strive to facilitate it each time you write a functor
class.</p></li>
</ul>
<h3
id="item-41.-understand-the-reasons-for-ptr_fun-mem_fun-and-mem_fun_ref.">Item
41. Understand the reasons for ptr_fun, mem_fun, and mem_fun_ref.</h3>
<ul>
<li><p>If I have a function f and an object x, I wish to invoke f on x,
and I'm outside x's member functions. C++ gives me three different
syntaxes for making the call:</p>
<p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">f</span>(x);	<span class="comment">// Syntax #1: when f is a non-member function</span></span><br><span class="line">x.<span class="built_in">f</span>();	<span class="comment">// Syntax #2: when f is a member function and x is an object or a reference to an object</span></span><br><span class="line">p-&gt;<span class="built_in">f</span>(); <span class="comment">// syntax #3: when f is a member function and p is a pointer to x</span></span><br></pre></td></tr></table></figure></p></li>
<li><p>A universal convention in the STL: functions and function objects
are always invoked using the syntactic form for non-member
functions.</p></li>
<li><p>mem_fun and mem_fun_ref arrange for member functions (which must
ordinarily be called using Syntax #2 or #3) to be called using Syntax
#1. They also provide important typedefs, just like the objects produced
by ptr_fun.</p></li>
<li><p>If you get confused about when to use ptr_fun and when not to,
consider using it every time you pass a function to an STL component.
The STL won't care, and there is no runtime penalty. An alternative
strategy with respect to ptr_fun is to use it only when you're forced
to. If you omit it when the typedefs are necessary, your compilers will
balk at your code. Then you'll have go back and add it.</p></li>
<li><p>The situation with mem_fun and mem_fun_ref is fundamentally
different. You must employ them whenever you pass a member function to
an STL component, because, in addition to adding typedefs (which may or
may not be necessary), they adapt the calling syntaxes from the ones
normally used with member functions to the one used everywhere in the
STL.</p></li>
</ul>
<h3 id="item-42.-make-sure-lesst-means-operator">Item 42. Make sure
less&lt;T&gt; means operator&lt;</h3>
<ul>
<li>Don't mislead all those programmers by playing games with the
definition of less. If you use less (explicitly or implicitly), make
sure it means operator&lt;. If you want to sort objects using some other
criterion, create a special functor class that's <strong>not</strong>
called less.</li>
</ul>
<h3 id="item-43.-prefer-algorithm-calls-to-hand-written-loops.">Item 43.
Prefer algorithm calls to hand-written loops.</h3>
<ul>
<li>Calling an algorithm is usually preferable to any hand-written loop.
There are three reasons:
<ul>
<li><strong>Efficiency:</strong> Algorithms are often more efficient
than the loops programmers produce.
<ul>
<li>Algorithms eliminate redundant computations.</li>
<li>Library implementers can take advantage of their knowledge of
container implementations to optimize traversals in a way that no
library user ever could.</li>
<li>All but the most trivial STL algorithms use computer science
algorithms that are more sophisticated — sometimes much more
sophisticated — than anything the average C++ programmer will be able to
come up with.</li>
</ul></li>
<li><strong>Correctness:</strong> Writing loops is more subject to
errors than is calling algorithms.</li>
<li><strong>Maintainability:</strong> Algorithm calls often yield code
that is clearer and more straightforward than the corresponding explicit
loops.</li>
</ul></li>
<li>If you need to do something an algorithm already does, or if you
need to do something very similar to what an algorithm does, the
algorithm call is clearer.</li>
<li>If you need a loop that does something fairly simple, but would
require a confusing tangle of binders and adapters or would require a
separate functor class if you were to use an algorithm, you're probably
better off just writing the loop.</li>
<li>Finally, if you need to do something fairly long and complex inside
the loop, the scales tilt back toward algorithms, because long, complex
computations should generally be moved into separate functions,
anyway.</li>
</ul>
<h3
id="item-44.-prefer-member-functions-to-algorithms-with-the-same-names.">Item
44. Prefer member functions to algorithms with the same names.</h3>
<ul>
<li>Most of the time, you'll want to use the member functions instead of
the algorithms. There are two reasons for this:
<ul>
<li>First, the member functions are faster.</li>
<li>Second, they integrate better with the containers (especially the
associative containers) than do the algorithms.</li>
</ul></li>
<li>For the standard associative containers, choosing member functions
over algorithms with the same names offers several benefits:
<ul>
<li>First, you get logarithmic-time instead of linear-time
performance.</li>
<li>Second, you determine whether two values are "the same" using
equivalence, which is the natural definition for associative
containers.</li>
<li>Third, when working with maps and multimaps, you automatically deal
only with key values instead of with (key, value) pairs.</li>
</ul></li>
<li>For list:
<ul>
<li>Each of the algorithms that list specializes (remove, remove_if,
unique, sort, merge, and reverse) copies objects, but list-specific
versions copy nothing: they simply manipulate the pointers connecting
list nodes. The algorithmic complexity of the algorithms and the member
functions is the same, but, under the assumption that manipulating
pointers is less expensive than copying objects, list's versions of
these functions should offer better performance.</li>
<li>Calls to the algorithms remove, remove_if, and unique must be
followed by calls to erase if you really want to eliminate objects from
a container, but list's remove, remove_if, and unique member functions
honestly get rid of elements: no subsequent call to erase is
necessary.</li>
<li>A significant difference between the sort algorithm and list's sort
function is that the former can't be applied to lists.</li>
<li>The merge algorithm isn't permitted to modify its source ranges, but
list-merge <strong>always</strong> modifies the lists it works on.</li>
</ul></li>
</ul>
<h3
id="item-45.-distinguish-among-count-find-binary-search-lower_bound-upper_bound-and-equal_range.">Item
45. Distinguish among count, find, binary search, lower_bound,
upper_bound, and equal_range.</h3>
<p><img data-src="https://ipichub.oss-cn-hangzhou.aliyuncs.com/2022-07-17-050643.png" /></p>
<ul>
<li>With lower_bound and upper_bound, it's too easy to fall back on
equality tests, but with equal_range, testing only for equivalence is
the natural thing to do.</li>
<li>For the multi containers, find is not guaranteed to identify the
first element in the container with a given value if more than one is
present: its charter is only to identify <strong>one</strong> of those
elements. If you really need to find the first object with a given
value, you'll want to employ lower_bound, and you'll have to manually
perform the second half of the equivalence test. (You could avoid the
manual equivalence test by using equal_range, but calling equal_range is
more expensive than calling lower_bound.)</li>
</ul>
<h3
id="item-46.-consider-function-objects-instead-of-functions-as-algorithm-parameters.">Item
46. Consider function objects instead of functions as algorithm
parameters.</h3>
<ul>
<li>Passing STL function objects to algorithms typically yields code
that is more efficient than passing real functions.
<ul>
<li>If a function object's operator() function has been declared inline
(either explicitly via inline or implicitly by defining it in its class
definition), the body of that function is available to compilers, and
most compilers will happily inline that function during template
instantiation of the called algorithm.</li>
<li>When we try to pass a function as a parameter, compilers silently
convert the function into a <strong>pointer</strong> to that function.
Most compilers won't try to inline calls to functions that are invoked
through function pointers, even if such functions have been declared
inline.</li>
</ul></li>
<li>The fact that function pointer parameters inhibit inlining explains
an observation that long-time C programmers often find hard to believe:
C++'s sort virtually always embarrasses C's qsort when it comes to
speed.</li>
<li>It's not uncommon for STL platforms to reject perfectly valid code,
either through shortcomings in the compiler or the library or both. For
example, a particular STL platform has a bug in its handling of const
member functions (such as string::size). A workaround is to use a
function object instead.</li>
<li>Another reason to prefer function objects to functions is that they
can help you avoid subtle language pitfalls. There are situations, for
example, when the name of an instantiation of a function template is not
equivalent to the name of a function, thus being rejected by
compilers.</li>
</ul>
<h3 id="item-47.-avoid-producing-write-only-code.">Item 47. Avoid
producing write-only code.</h3>
<ul>
<li>As you write the code, it seems straightforward, because it's a
natural outgrowth of some basic ideas. <strong>Readers</strong>,
however, have great difficulty in decomposing the final product back
into the ideas on which it is based. That's the calling card of
write-only code: it's easy to write, but it's hard to read and
understand.</li>
<li>It's a software engineering truism that code is read more often than
it is written. Equally well established is that software spends far more
time in maintenance than it does in development. Software that cannot be
read and understood cannot be maintained, and software that cannot be
maintained is hardly worth having. The more you work with the STL, the
more comfortable you'll become with it, and the more you'll feel the
pull to nest function calls and create function objects on the fly.
There's nothing wrong with that, but always bear in mind that the code
you write today will be read by somebody — possibly you — someday in the
future. Prepare for that day.</li>
</ul>
<h3 id="item-48.-always-include-the-proper-headers.">Item 48. Always
#include the proper headers.</h3>
<ul>
<li>Any time you refer to elements of namespace std, you are responsible
for having #included the appropriate headers. If you omit them, your
code might compile anyway, but you'll still be missing necessary
headers, and other STL platforms may justly reject your code.</li>
<li>To help you remember what's required when, here's a quick summary of
what's in each standard STL-related header:
<ul>
<li>Almost all the containers are declared in headers of the same name,
i.e., vector is declared in &lt;vector&gt;, list is declared in
&lt;list&gt;, etc. The exceptions are &lt;set&gt; and &lt;map&gt;.
&lt;set&gt; declares both set and multiset, and &lt;map&gt; declares
both map and multimap.</li>
<li>All but four algorithms are declared in &lt;algorithm&gt;. The
exceptions are accumulate, inner_product, adjacent_difference, and
partial_sum. Those algorithms are declared in &lt;numeric&gt;.</li>
<li>Special kinds of iterators, including istream_iterators and
istreambuf_iterators, are declared in &lt;iterator&gt;.</li>
<li>Standard functors (e.g., less&lt;T&gt;) and functor adapters (e.g.,
not1, bind2nd) are declared in &lt;functional&gt;.</li>
</ul></li>
</ul>
<h3
id="item-49.-learn-to-decipher-stl-related-compiler-diagnostics.">Item
49. Learn to decipher STL-related compiler diagnostics.</h3>
<p>A few hints that should help you make sense of STL-related compiler
messages:</p>
<ul>
<li>You can almost always reduce compiler diagnostics to something
comprehensible by replacing lengthy template-based type names with
shorter mnemonics. In many cases, all you have to do is replace typedef
expansions with typedef names you're already using.</li>
<li>For vector and string, iterators are usually pointers, so compiler
diagnostics will likely refer to pointer types if you've made a mistake
with an iterator.</li>
<li>Messages mentioning back_insert_iterator, front_insert_iterator, or
insert_iterator almost always mean you've made a mistake calling
back_inserter, front_inserter, or inserter, respectively. If you didn't
call these functions, some function you called (directly or indirectly)
did.</li>
<li>Similarly, if you get a message mentioning binder1st or binder2nd,
you've probably made a mistake using bind1st or bind2nd.</li>
<li>Output iterators (e.g., ostream_iterators, ostreambuf_iterators, and
the iterators returned from back_inserter, front_inserter, and inserter)
do their outputting or inserting work inside assignment operators, so if
you've made a mistake with one of these iterator types, you're likely to
get a message complaining about something inside an assignment operator
you've never heard of.</li>
<li>If you get an error message originating from inside the
implementation of an STL algorithm, there's probably something wrong
with the types you're trying to use with that algorithm. For example,
you may be passing iterators of the wrong category.</li>
<li>If you're using a common STL component like vector, string, or the
for_each algorithm, and a compiler says it has no idea what you're
talking about, you've probably failed to #include a required header
file.</li>
</ul>
<h3 id="item-50.-familiarize-yourself-with-stl-related-web-sites.">Item
50. Familiarize yourself with STL-related web sites.</h3>
<ul>
<li><strong>The SGI STL site,</strong>
http://www.sgi.com/tech/stl/.</li>
<li><strong>The STLport site,</strong> http://www.stlport.org/.</li>
<li><strong>The Boost site,</strong> http://www.boost.org/.</li>
</ul>

    </div>

    
    
    

    <footer class="post-footer">
          <div class="reward-container">
  <div></div>
  <button>
    Donate
  </button>
  <div class="post-reward">
      <div>
        <img src="/images/wechatpay.png" alt="Yuheng Ding WeChat Pay">
        <span>WeChat Pay</span>
      </div>
      <div>
        <img src="/images/alipay.jpg" alt="Yuheng Ding Alipay">
        <span>Alipay</span>
      </div>

  </div>
</div>

          <div class="post-tags">
              <a href="/tags/C-C/" rel="tag"># C/C++</a>
              <a href="/tags/STL/" rel="tag"># STL</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2021/10/06/effective-modern-cpp/" rel="prev" title="[Note] Effective Modern C++">
                  <i class="fa fa-chevron-left"></i> [Note] Effective Modern C++
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2022/03/18/programmers-self-cultivation-part-1/" rel="next" title="[Note] 程序员的自我修养——第 1 部分 简介">
                  [Note] 程序员的自我修养——第 1 部分 简介 <i class="fa fa-chevron-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






    <div class="comments gitalk-container"></div>
</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 2018 – 
  <span itemprop="copyrightYear">2024</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Yuheng Ding</span>
</div>
<div class="wordcount">
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-line"></i>
    </span>
      <span>Symbols count total: </span>
    <span title="Symbols count total">370k</span>
  </span>
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
      <span>Reading time total &asymp;</span>
    <span title="Reading time total">5:37</span>
  </span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/" rel="noopener" target="_blank">NexT.Gemini</a>
  </div>

    </div>
  </footer>

  
  <script size="300" alpha="0.6" zIndex="-1" src="https://cdn.jsdelivr.net/npm/ribbon.js@1.0.2/dist/ribbon.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@next-theme/pjax@0.5.0/pjax.min.js" integrity="sha256-3NkoLDrmHLTYj7csHIZSr0MHAFTXth7Ua/DDt4MRUAg=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js" integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js" integrity="sha256-yt2kYMy0w8AbtF89WXb2P1rfjcP/HTHLT7097U8Y5b8=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/lozad@1.16.0/dist/lozad.min.js" integrity="sha256-mOFREFhqmHeQbXpK2lp4nA3qooVgACfh88fpJftLBbc=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script><script src="/js/pjax.js"></script>

  



  <script src="/js/third-party/fancybox.js"></script>


  




  

  <script class="next-config" data-name="enableMath" type="application/json">false</script><script class="next-config" data-name="mathjax" type="application/json">{"enable":true,"tags":"none","js":{"url":"https://cdn.jsdelivr.net/npm/mathjax@3.2.0/es5/tex-mml-chtml.js","integrity":"sha256-r+3itOMtGGjap0x+10hu6jW/gZCzxHsoKrOd7gyRSGY="}}</script>
<script src="/js/third-party/math/mathjax.js"></script>


<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/gitalk@1.7.2/dist/gitalk.css" integrity="sha256-AJnUHL7dBv6PGaeyPQJcgQPDjt/Hn/PvYZde1iqfp8U=" crossorigin="anonymous">

<script class="next-config" data-name="gitalk" type="application/json">{"enable":true,"github_id":"timdyh","repo":"gitalk-comments","client_id":"0babcb65af364dd08a90","client_secret":"22090e837380d49040a73f2ed1db4f9541b29379","admin_user":"timdyh","distraction_free_mode":true,"proxy":"https://cors-anywhere.azm.workers.dev/https://github.com/login/oauth/access_token","language":null,"js":{"url":"https://cdn.jsdelivr.net/npm/gitalk@1.7.2/dist/gitalk.min.js","integrity":"sha256-Pmj85ojLaPOWwRtlMJwmezB/Qg8BzvJp5eTzvXaYAfA="},"path_md5":"fdc4076694231295ca5d99b3307472b9"}</script>
<script src="/js/third-party/comments/gitalk.js"></script>

</body>
</html>
